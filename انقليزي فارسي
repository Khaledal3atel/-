import random
import time
import re
import requests
import json
import os
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from collections import defaultdict

BOT_TOKEN = "8494424963:AAF6-S97oBbAqHR6XZ6C2DBvJKDNcIe_Tbk" 
OWNER_ID = 5562144078

message_cache = {}
last_save_time = time.time()
save_interval = 2.0

chat_locks = defaultdict(asyncio.Lock)
last_command_time = defaultdict(lambda: defaultdict(float))

URLS = {
    "Ø¬Ù…Ù…": "https://raw.githubusercontent.com/AL3ATEL/TXT-bot-telegram-/refs/heads/main/sentences.txt",
    "Ø´Ø±Ø·": "https://raw.githubusercontent.com/AL3ATEL/txt-telegram-2/refs/heads/main/conditions.txt",
    "ÙÙƒÙƒ": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/3kswdblwtrdl.txt",
    "ØµØ¬": "https://raw.githubusercontent.com/AL3ATEL/txt-telegram-4/refs/heads/main/arabic_sentences.json",
    "Ø¬Ø´": "https://raw.githubusercontent.com/BoulahiaAhmed/Arabic-Quotes-Dataset/main/Arabic_Quotes.csv",
    "Ø´Ùƒ": "https://raw.githubusercontent.com/AL3ATEL/txt-telegram-5/refs/heads/main/3amh.txt",
    "ÙˆÙŠÙƒÙŠ": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/Wekebedea.txt",
    "Ø¯Ø¨Ù„": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/3kswdblwtrdl.txt",
    "ØªØ±": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/3kswdblwtrdl.txt",
    "Ø¹ÙƒØ³": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/3kswdblwtrdl.txt",
    "ÙØ±": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/Farsi.txt",
    "E": "https://raw.githubusercontent.com/Khaledal3atel/-/refs/heads/main/English.txt"
}

REPEAT_WORDS = ["ØµÙ…Øª", "ØµÙˆÙ", "Ø³ÙŠÙ†", "Ø¹ÙŠÙ†", "Ø¬ÙŠÙ…", "ÙƒØªØ¨", "Ø®Ø¨Ø±", "Ø­Ù„Ù…", "Ø¬Ù…Ù„", "ØªØ¹Ø¨", "Ø¹Ø±Ø¨", "Ù†Ø§Ø±", "Ø¨Ø±Ø¯", "Ù†Ø³Ø±", "Ø·Ø±Ø¨", "Ø´Ùƒ", "Ø«ÙˆØ±", "Ø®Ø³Ø±", "Ø¹Ù„Ù…", "ØµÙˆØª", "Ø³ÙˆÙ†", "ÙƒÙ„", "Ø«ÙˆØ¨", "Ù‡Ø§Øª", "Ù‡Ù…Ø³"]

CONDITIONS = [
    "ÙƒØ±Ø± Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø©",
    "ÙƒØ±Ø± Ø«Ø§Ù†ÙŠ ÙƒÙ„Ù…Ø©",
    "ÙƒØ±Ø± Ø¢Ø®Ø± ÙƒÙ„Ù…Ø©",
    "ÙƒØ±Ø± Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø© ÙˆØ¢Ø®Ø± ÙƒÙ„Ù…Ø©",
    "ÙÙƒÙƒ Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø©",
    "ÙÙƒÙƒ Ø¢Ø®Ø± ÙƒÙ„Ù…Ø©",
    "Ø¨Ø¯Ù„ Ø£ÙˆÙ„ ÙƒÙ„Ù…ØªÙŠÙ†",
    "Ø¨Ø¯Ù„ Ø¢Ø®Ø± ÙƒÙ„Ù…ØªÙŠÙ†",
    "Ø¨Ø¯Ù„ Ø«Ø§Ù†ÙŠ ÙƒÙ„Ù…Ø© ÙˆØ§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©"
]

CHAR_MAP = {'Ø£': 'Ø§', 'Ø¥': 'Ø§', 'Ø¢': 'Ø§', 'Ù‰': 'ÙŠ', 'Ø©': 'Ù‡', 'Ø¦': 'ÙŠ', 'Ø¤': 'Ùˆ', 'Ù±': 'Ø§', 'Ù³': 'Ø§'}
NUM_WORDS = {'0': 'ØµÙØ±', '1': 'ÙˆØ§Ø­Ø¯', '2': 'Ø§Ø«Ù†Ø§Ù†', '3': 'Ø«Ù„Ø§Ø«Ø©', '4': 'Ø£Ø±Ø¨Ø¹Ø©', '5': 'Ø®Ù…Ø³Ø©', '6': 'Ø³ØªØ©', '7': 'Ø³Ø¨Ø¹Ø©', '8': 'Ø«Ù…Ø§Ù†ÙŠØ©', '9': 'ØªØ³Ø¹Ø©', '10': 'Ø¹Ø´Ø±Ø©', '11': 'Ø§Ø­Ø¯Ù‰ Ø¹Ø´Ø±', '12': 'Ø§Ø«Ù†Ø§ Ø¹Ø´Ø±', '13': 'Ø«Ù„Ø§Ø«Ø© Ø¹Ø´Ø±', '14': 'Ø£Ø±Ø¨Ø¹Ø© Ø¹Ø´Ø±', '15': 'Ø®Ù…Ø³Ø© Ø¹Ø´Ø±', '16': 'Ø³ØªØ© Ø¹Ø´Ø±', '17': 'Ø³Ø¨Ø¹Ø© Ø¹Ø´Ø±', '18': 'Ø«Ù…Ø§Ù†ÙŠØ© Ø¹Ø´Ø±', '19': 'ØªØ³Ø¹Ø© Ø¹Ø´Ø±', '20': 'Ø¹Ø´Ø±ÙˆÙ†', '30': 'Ø«Ù„Ø§Ø«ÙˆÙ†', '40': 'Ø£Ø±Ø¨Ø¹ÙˆÙ†', '50': 'Ø®Ù…Ø³ÙˆÙ†', '60': 'Ø³ØªÙˆÙ†', '70': 'Ø³Ø¨Ø¹ÙˆÙ†', '80': 'Ø«Ù…Ø§Ù†ÙˆÙ†', '90': 'ØªØ³Ø¹ÙˆÙ†', '100': 'Ù…Ø§Ø¦Ø©', '1000': 'Ø£Ù„Ù'}

class Storage:
    def __init__(self):
        self.file = "bot_data.json"
        self.data = self.load()
        self.dirty = False

    def load(self):
        try:
            with open(self.file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {
                "users": {},
                "chats": {},
                "banned": [],
                "scores": {},
                "patterns": {},
                "sessions": {},
                "awards": {},
                "weekly_awards": {},
                "stats": {},
                "broadcast_mode": {},
                "rounds": {},
                "round_mode": {},
                "pending_round_setup": {},
                "admins": [],
                "owners": []
            }

    def save(self, force=False):
        global last_save_time
        current_time = time.time()

        if not self.dirty and not force:
            return

        if not force and (current_time - last_save_time) < save_interval:
            return

        try:
            with open(self.file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
            self.dirty = False
            last_save_time = current_time
            print(f"[STORAGE] Data saved successfully at {datetime.now().strftime('%H:%M:%S')}")
        except Exception as e:
            print(f"Error saving data: {e}")

    def mark_dirty(self):
        self.dirty = True

    def add_user(self, uid, usr, name):
        self.data["users"][str(uid)] = {
            "username": usr,
            "first_name": name,
            "created_at": datetime.now().isoformat()
        }
        self.mark_dirty()

    def add_chat(self, cid, title):
        self.data["chats"][str(cid)] = {
            "title": title,
            "created_at": datetime.now().isoformat()
        }
        self.mark_dirty()

    def is_banned(self, uid):
        uid_str = str(uid)
        is_in_list = uid_str in self.data["banned"]
        return is_in_list

    def ban_user(self, uid):
        uid_str = str(uid)
        if uid_str not in self.data["banned"]:
            self.data["banned"].append(uid_str)
            print(f"[BAN] User {uid} has been banned. Updated banned list: {self.data['banned']}")

        sessions_to_remove = []
        for key, session in self.data["sessions"].items():
            if session.get("starter_uid") == uid:
                sessions_to_remove.append(key)

        for key in sessions_to_remove:
            self.data["sessions"].pop(key, None)

        self.mark_dirty()
        self.save(force=True)

    def unban_user(self, uid):
        uid_str = str(uid)
        print(f"[UNBAN] Attempting to unban user {uid}. Current banned list: {self.data['banned']}")

        if uid_str in self.data["banned"]:
            self.data["banned"].remove(uid_str)
            self.mark_dirty()
            self.save(force=True)
            print(f"[UNBAN] User {uid} has been unbanned. Updated banned list: {self.data['banned']}")
            return True
        else:
            print(f"[UNBAN] User {uid} was not in banned list")
            return False

    def is_admin(self, uid):
        return str(uid) in self.data["admins"]

    def is_owner(self, uid):
        return str(uid) in self.data["owners"]

    def is_main_owner(self, uid):
        return uid == OWNER_ID

    def add_admin(self, uid):
        uid_str = str(uid)
        if uid_str not in self.data["admins"]:
            self.data["admins"].append(uid_str)
            self.mark_dirty()
            self.save(force=True)

    def add_owner(self, uid):
        uid_str = str(uid)
        if uid_str not in self.data["owners"]:
            self.data["owners"].append(uid_str)
            self.mark_dirty()
            self.save(force=True)

    def remove_admin(self, uid):
        uid_str = str(uid)
        if uid_str in self.data["admins"]:
            self.data["admins"].remove(uid_str)
            self.mark_dirty()
            self.save(force=True)

    def remove_owner(self, uid):
        uid_str = str(uid)
        if uid_str in self.data["owners"]:
            self.data["owners"].remove(uid_str)
            self.mark_dirty()
            self.save(force=True)

    def get_all_admins(self):
        return self.data["admins"]

    def get_all_owners(self):
        return self.data["owners"]

    def update_score(self, uid, typ, wpm):
        key = f"{uid}_{typ}"
        self.data["scores"][key] = max(self.data["scores"].get(key, 0), wpm)
        self.mark_dirty()

    def get_score(self, uid, typ):
        return self.data["scores"].get(f"{uid}_{typ}", 0)

    def add_pattern(self, uid, key):
        if str(uid) not in self.data["patterns"]:
            self.data["patterns"][str(uid)] = []
        if key not in self.data["patterns"][str(uid)]:
            self.data["patterns"][str(uid)].append(key)
            self.mark_dirty()

    def is_pattern_used(self, uid, key):
        return key in self.data["patterns"].get(str(uid), [])

    def clear_patterns(self, uid):
        self.data["patterns"][str(uid)] = []
        self.mark_dirty()

    def save_session(self, uid, cid, typ, txt, tm, sent=False):
        key = f"{cid}_{typ}"
        self.data["sessions"][key] = {
            "type": typ,
            "text": txt,
            "time": tm,
            "starter_uid": uid,
            "sent": sent
        }
        self.mark_dirty()

    def mark_session_sent(self, cid, typ):
        key = f"{cid}_{typ}"
        if key in self.data["sessions"]:
            self.data["sessions"][key]["sent"] = True
            self.mark_dirty()

    def get_session(self, cid, typ):
        return self.data["sessions"].get(f"{cid}_{typ}")

    def get_all_active_sessions(self, cid):
        expired_keys = []
        active_sessions = []

        for key, session in list(self.data["sessions"].items()):
            if key.startswith(f"{cid}_"):
                elapsed = time.time() - session.get("time", 0)
                if elapsed <= 60:
                    active_sessions.append(session)
                else:
                    expired_keys.append(key)

        for key in expired_keys:
            self.data["sessions"].pop(key, None)
        if expired_keys:
            self.mark_dirty()

        return active_sessions

    def del_session(self, cid, typ):
        self.data["sessions"].pop(f"{cid}_{typ}", None)
        self.mark_dirty()

    def cancel_user_session_in_type(self, uid, cid, typ):
        key = f"{cid}_{typ}"
        session = self.data["sessions"].get(key)
        if session and session.get("starter_uid") == uid:
            self.data["sessions"].pop(key, None)
            self.mark_dirty()
            return True
        return False

    def get_leaderboard(self, typ):
        scores = []
        for k, v in self.data["scores"].items():
            if k.endswith(f"_{typ}"):
                uid = k.split('_')[0]
                user_data = self.data["users"].get(uid, {})
                username = user_data.get("username")
                first_name = user_data.get("first_name", "Ù…Ø³ØªØ®Ø¯Ù…")
                scores.append((uid, username, first_name, v))

        scores.sort(key=lambda x: x[3], reverse=True)
        return scores[:3]

    def add_award(self, uid, name, wpm, typ):
        if str(uid) not in self.data["weekly_awards"]:
            self.data["weekly_awards"][str(uid)] = []

        self.data["weekly_awards"][str(uid)].append({
            "name": name,
            "wpm": wpm,
            "type": typ,
            "date": datetime.now().isoformat()
        })
        self.mark_dirty()

    def get_awards(self, uid):
        return self.data["weekly_awards"].get(str(uid), [])

    def log_cmd(self, cmd):
        dt = datetime.now().strftime("%Y-%m-%d")
        if dt not in self.data["stats"]:
            self.data["stats"][dt] = {}
        if cmd not in self.data["stats"][dt]:
            self.data["stats"][dt][cmd] = 0
        self.data["stats"][dt][cmd] += 1
        self.mark_dirty()

    def set_broadcast_mode(self, uid, status):
        self.data["broadcast_mode"][str(uid)] = status
        self.mark_dirty()
        self.save(force=True)

    def get_broadcast_mode(self, uid):
        return self.data["broadcast_mode"].get(str(uid), False)

    def start_round(self, cid, target, starter_uid=None):
        self.data["rounds"][str(cid)] = {
            "target": target,
            "wins": {},
            "started_at": datetime.now().isoformat(),
            "last_activity": time.time(),
            "starter_uid": starter_uid
        }
        self.mark_dirty()

    def update_round_activity(self, cid):
        if str(cid) in self.data["rounds"]:
            self.data["rounds"][str(cid)]["last_activity"] = time.time()
            self.mark_dirty()

    def get_round(self, cid):
        return self.data["rounds"].get(str(cid))

    def end_round(self, cid):
        self.data["rounds"].pop(str(cid), None)
        self.mark_dirty()

    def add_win(self, cid, uid):
        if str(cid) not in self.data["rounds"]:
            return False

        if str(uid) not in self.data["rounds"][str(cid)]["wins"]:
            self.data["rounds"][str(cid)]["wins"][str(uid)] = 0

        self.data["rounds"][str(cid)]["wins"][str(uid)] += 1
        self.mark_dirty()
        return self.data["rounds"][str(cid)]["wins"][str(uid)]

    def set_round_mode(self, cid, status):
        self.data["round_mode"][str(cid)] = status
        self.mark_dirty()

    def get_round_mode(self, cid):
        return self.data["round_mode"].get(str(cid), False)

    def cleanup(self):
        now = time.time()
        to_del = []
        for k, v in self.data["sessions"].items():
            if now - v["time"] > 3600:
                to_del.append(k)

        for k in to_del:
            del self.data["sessions"][k]

        month_ago = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d")
        for dt in list(self.data["stats"].keys()):
            if dt < month_ago:
                del self.data["stats"][dt]

        if to_del:
            self.mark_dirty()

    def cleanup_inactive_rounds(self):
        now = time.time()
        rounds_to_remove = []

        for cid, round_data in list(self.data["rounds"].items()):
            last_activity = round_data.get("last_activity", 0)
            if now - last_activity > 120:
                rounds_to_remove.append(cid)

        for cid in rounds_to_remove:
            self.data["rounds"].pop(cid, None)

        if rounds_to_remove:
            self.mark_dirty()

        return rounds_to_remove

    def set_pending_round_setup(self, cid, uid, status):
        key = str(cid)
        if status:
            self.data["pending_round_setup"][key] = uid
        else:
            self.data["pending_round_setup"].pop(key, None)
        self.mark_dirty()

    def get_pending_round_setup(self, cid):
        return self.data["pending_round_setup"].get(str(cid))

    def get_round_stats(self, cid):
        round_data = self.get_round(cid)
        if not round_data:
            return None

        target = round_data.get("target", 0)
        wins = round_data.get("wins", {})
        started_at = round_data.get("started_at", "")

        if not wins:
            return f"Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n\nØ§Ù„Ù‡Ø¯Ù: {target} Ø§Ù†ØªØµØ§Ø±\nØ§Ù„Ù…Ø´Ø§Ø±ÙƒÙˆÙ†: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø¹Ø¯\nØ¨Ø¯Ø£Øª: {started_at[:16]}"

        sorted_wins = sorted(wins.items(), key=lambda x: x[1], reverse=True)

        stats_msg = f"Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n\nØ§Ù„Ù‡Ø¯Ù: {target} Ø§Ù†ØªØµØ§Ø±\n\nØ§Ù„Ù…Ø´Ø§Ø±ÙƒÙˆÙ†:\n"

        for idx, (uid, count) in enumerate(sorted_wins, 1):
            user_info = self.data["users"].get(str(uid), {})
            name = user_info.get("first_name", "Ù…Ø³ØªØ®Ø¯Ù…")
            username = user_info.get("username", "")
            display_name = f"@{username}" if username else name
            stats_msg += f"{idx}. {display_name}: {count} Ø§Ù†ØªØµØ§Ø±\n"

        stats_msg += f"\nØ¨Ø¯Ø£Øª: {started_at[:16]}"

        return stats_msg

storage = Storage()

class RemoteManager:
    def __init__(self, url, min_words=5, max_words=25, disasm=False, is_english=False):
        self.url = url
        self.min_words = min_words
        self.max_words = max_words
        self.disasm = disasm
        self.is_english = is_english
        self.sentences = []
        self.last_update = 0

    def load(self):
        try:
            r = requests.get(self.url, timeout=10)
            if r.status_code == 200:
                if self.url.endswith('.json'):
                    data = r.json()
                    self.sentences = [
                        clean(s, keep_english=self.is_english) for s in data
                        if s.strip() and self.min_words <= len(clean(s, keep_english=self.is_english).split()) <= self.max_words
                    ]
                else:
                    if self.is_english:
                        all_text = r.text.strip()
                        raw_sentences = []
                        for line in all_text.split('\n'):
                            if ',' in line:
                                raw_sentences.extend([s.strip() for s in line.split(',')])
                            else:
                                raw_sentences.append(line.strip())
                        
                        self.sentences = [
                            clean(s, keep_english=True) for s in raw_sentences
                            if s.strip() and self.min_words <= len(clean(s, keep_english=True).split()) <= self.max_words
                        ]
                    else:
                        self.sentences = [
                            clean(s) for s in r.text.split('\n')
                            if s.strip() and self.min_words <= len(clean(s).split()) <= self.max_words
                        ]
                self.last_update = time.time()
        except Exception as e:
            print(f"Error loading from {self.url}: {e}")

    def get(self):
        if not self.sentences or time.time() - self.last_update > 3600:
            self.load()
        return random.choice(self.sentences) if self.sentences else "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù…Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹"

class CSVQuotesManager:
    def __init__(self, url, min_words=3, max_words=30):
        self.url = url
        self.min_words = min_words
        self.max_words = max_words
        self.quotes = []
        self.last_update = 0

    def load(self):
        try:
            r = requests.get(self.url, timeout=10)
            if r.status_code == 200:
                lines = r.text.strip().split('\n')[1:]
                self.quotes = []
                for line in lines:
                    if '","' in line or ',' in line:
                        parts = line.split('","')
                        if len(parts) >= 1:
                            quote = parts[0].strip('"').strip()
                            quote = clean(quote)
                            if quote and self.min_words <= len(quote.split()) <= self.max_words:
                                self.quotes.append(quote)
                self.last_update = time.time()
        except Exception as e:
            print(f"Error loading quotes: {e}")

    def get(self):
        if not self.quotes or time.time() - self.last_update > 3600:
            self.load()
        return random.choice(self.quotes) if self.quotes else "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ù‚ØªØ¨Ø§Ø³Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹"

def clean(txt, keep_english=False):
    txt = re.sub(r'[\u064B-\u065F\u0670]', '', txt.replace(' â‰ˆ ', ' ').replace('â‰ˆ', ' '))
    txt = re.sub(r'\([^)]*[a-zA-Z]+[^)]*\)', '', txt)
    txt = re.sub(r'\[[^\]]*\]', '', txt)
    txt = re.sub(r'\([^)]*\)', '', txt)
    
    if not keep_english:
        txt = ' '.join([w for w in txt.split() if not re.search(r'[a-zA-Z]', w)])

    def rep_num(m):
        n = m.group()
        return NUM_WORDS.get(n, ' '.join(NUM_WORDS.get(d, d) for d in n) if len(n) > 1 else n)

    txt = re.sub(r'\d+', rep_num, txt)
    txt = re.sub(r'[ØŒ,:;Ø›\-â€“â€”\.\!ØŸ\?\(\)\[\]\{\}""''Â«Â»â€¦]', ' ', txt)
    return re.sub(r'\s+', ' ', txt).strip()

def normalize(txt):
    txt = re.sub(r'[\u064B-\u065F\u0670]', '', txt)
    return re.sub(r'\s+', ' ', ''.join(CHAR_MAP.get(c, c) for c in txt)).strip()

def format_display(s):
    return ' ØŒ '.join(s.split())

def count_words_for_wpm(text):
    cleaned_text = re.sub(r'[â‰ˆ=\-~_|/\\ØŒ,:;Ø›\.\!ØŸ\?\(\)\[\]\{\}""''Â«Â»â€¦]+', ' ', text)
    cleaned_text = re.sub(r'\s+', ' ', cleaned_text).strip()
    words = cleaned_text.split()
    return len(words)

def match_text(orig, usr):
    orig_normalized = normalize(orig)
    usr_normalized = normalize(usr)

    if orig_normalized == usr_normalized:
        return True

    usr_with_spaces = re.sub(r'[â‰ˆ=\-~_|/\\]+', ' ', usr)
    usr_with_spaces_normalized = normalize(usr_with_spaces)

    if orig_normalized == usr_with_spaces_normalized:
        return True

    words = usr_with_spaces_normalized.split()
    if len(words) >= 2:
        reversed_text = ' '.join(reversed(words))
        if orig_normalized == reversed_text:
            return True

    return False

def norm_spaces(txt):
    return re.sub(r'\s+', ' ', txt).strip()

def disassemble_word(word):
    return ' '.join(list(word))

def assemble_word(disassembled_word):
    return disassembled_word.replace(' ', '')

def disassemble_sentence(sentence):
    words = sentence.split()
    return ' '.join([disassemble_word(word) for word in words])

def assemble_sentence(disassembled_sentence):
    words = disassembled_sentence.split()
    assembled_words = []
    current_word = []

    for char in words:
        if char.strip():
            current_word.append(char)
        if len(current_word) > 0 and (not char.strip() or char == words[-1]):
            assembled_words.append(assemble_word(' '.join(current_word)))
            current_word = []

    return ' '.join(assembled_words)

def is_correct_disassembly(original, user_disassembly):
    expected = disassemble_sentence(original)
    return normalize(user_disassembly) == normalize(expected)

def is_correct_assembly(original_disassembled, user_assembly):
    expected = assemble_sentence(original_disassembled)
    return normalize(user_assembly) == normalize(expected)

def apply_condition(cond, sent):
    words = sent.split()
    if not words:
        return sent

    if cond == "ÙƒØ±Ø± Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø©":
        return f"{words[0]} {sent}"

    elif cond == "ÙƒØ±Ø± Ø«Ø§Ù†ÙŠ ÙƒÙ„Ù…Ø©" and len(words) >= 2:
        return f"{words[1]} {sent}"

    elif cond == "ÙƒØ±Ø± Ø¢Ø®Ø± ÙƒÙ„Ù…Ø©":
        return f"{sent} {words[-1]}"

    elif cond == "ÙƒØ±Ø± Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø© ÙˆØ¢Ø®Ø± ÙƒÙ„Ù…Ø©":
        return f"{words[0]} {sent} {words[-1]}"

    elif cond == "ÙÙƒÙƒ Ø£ÙˆÙ„ ÙƒÙ„Ù…Ø©":
        return f"{' '.join(words[0])} {' '.join(words[1:])}" if len(words) > 1 else ' '.join(words[0])

    elif cond == "ÙÙƒÙƒ Ø¢Ø®Ø± ÙƒÙ„Ù…Ø©":
        return f"{' '.join(words[:-1])} {' '.join(words[-1])}" if len(words) > 1 else ' '.join(words[-1])

    elif cond == "Ø¨Ø¯Ù„ Ø£ÙˆÙ„ ÙƒÙ„Ù…ØªÙŠÙ†" and len(words) >= 2:
        words[0], words[1] = words[1], words[0]
        return ' '.join(words)

    elif cond == "Ø¨Ø¯Ù„ Ø¢Ø®Ø± ÙƒÙ„Ù…ØªÙŠÙ†" and len(words) >= 2:
        words[-1], words[-2] = words[-2], words[-1]
        return ' '.join(words)

    elif cond == "Ø¨Ø¯Ù„ Ø«Ø§Ù†ÙŠ ÙƒÙ„Ù…Ø© ÙˆØ§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©" and len(words) >= 3:
        words[1], words[-1] = words[-1], words[1]
        return ' '.join(words)

    return sent

def validate_condition(cond, orig, usr):
    expected = apply_condition(cond, orig)
    return normalize(usr) == normalize(expected), expected

def validate_repeat(exp, usr):
    matches = re.findall(r'(\S+)\((\d+)\)', exp)
    user_words = usr.split()
    total = sum(int(c) for _, c in matches)

    if len(user_words) != total:
        return False, f"Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ù…ÙØªØ±Ø¶: {total}"

    idx = 0
    for word, count in matches:
        for j in range(idx, idx + int(count)):
            if normalize(user_words[j]) != normalize(word):
                return False, f"Ø§Ù„ÙƒÙ„Ù…Ø© '{user_words[j]}' ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '{word}'"
        idx += int(count)

    return True, ""

def validate_double(original_sentence, user_text):
    original_words = original_sentence.split()
    user_words = user_text.split()

    if len(user_words) != len(original_words) * 2:
        return False, f"Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ù…ÙØªØ±Ø¶: {len(original_words) * 2}"

    idx = 0
    for word in original_words:
        if normalize(user_words[idx]) != normalize(word):
            return False, f"Ø§Ù„ÙƒÙ„Ù…Ø© '{user_words[idx]}' ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '{word}'"
        if normalize(user_words[idx + 1]) != normalize(word):
            return False, f"Ø§Ù„ÙƒÙ„Ù…Ø© '{user_words[idx + 1]}' ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '{word}'"
        idx += 2

    return True, ""

def validate_triple(original_sentence, user_text):
    original_words = original_sentence.split()
    user_words = user_text.split()

    if len(user_words) != len(original_words) * 3:
        return False, f"Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ù…ÙØªØ±Ø¶: {len(original_words) * 3}"

    idx = 0
    for word in original_words:
        for i in range(3):
            if normalize(user_words[idx + i]) != normalize(word):
                return False, f"Ø§Ù„ÙƒÙ„Ù…Ø© '{user_words[idx + i]}' ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '{word}'"
        idx += 3

    return True, ""

def validate_reverse(original_sentence, user_text):
    original_words = original_sentence.split()
    user_words = user_text.split()

    if len(user_words) != len(original_words):
        return False, f"Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ù…ÙØªØ±Ø¶: {len(original_words)}"

    reversed_original = list(reversed(original_words))
    for i, word in enumerate(reversed_original):
        if normalize(user_words[i]) != normalize(word):
            return False, f"Ø§Ù„ÙƒÙ„Ù…Ø© '{user_words[i]}' ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† '{word}'"

    return True, ""

def gen_pattern(uid):
    for _ in range(100):
        words = random.sample(REPEAT_WORDS, 4)
        pattern = []
        key_parts = []

        for w in words:
            c = random.randint(2, 4)
            pattern.append(f"{w}({c})")
            key_parts.append(f"{w}_{c}")

        key = '_'.join(key_parts)
        if not storage.is_pattern_used(uid, key):
            storage.add_pattern(uid, key)
            return ' '.join(pattern)

    storage.clear_patterns(uid)
    return gen_pattern(uid)

def arabic_to_num(txt):
    txt = txt.strip()
    nums = {
        'ØµÙØ±': 0, 'ÙˆØ§Ø­Ø¯': 1, 'Ø§Ø«Ù†Ø§Ù†': 2, 'Ø§Ø«Ù†ÙŠÙ†': 2, 'Ø«Ù„Ø§Ø«Ø©': 3, 'Ø«Ù„Ø§Ø«': 3, 'Ø£Ø±Ø¨Ø¹Ø©': 4, 'Ø£Ø±Ø¨Ø¹': 4,
        'Ø®Ù…Ø³Ø©': 5, 'Ø®Ù…Ø³': 5, 'Ø³ØªØ©': 6, 'Ø³Øª': 6, 'Ø³Ø¨Ø¹Ø©': 7, 'Ø³Ø¨Ø¹': 7, 'Ø«Ù…Ø§Ù†ÙŠØ©': 8, 'Ø«Ù…Ø§Ù†ÙŠ': 8, 'Ø«Ù…Ø§Ù†': 8,
        'ØªØ³Ø¹Ø©': 9, 'ØªØ³Ø¹': 9, 'Ø¹Ø´Ø±Ø©': 10, 'Ø¹Ø´Ø±': 10,
        'Ø§Ø­Ø¯Ù‰ Ø¹Ø´Ø±': 11, 'Ø§Ø­Ø¯ Ø¹Ø´Ø±': 11, 'Ø§Ø«Ù†Ø§ Ø¹Ø´Ø±': 12, 'Ø§Ø«Ù†ÙŠ Ø¹Ø´Ø±': 12,
        'Ø«Ù„Ø§Ø«Ø© Ø¹Ø´Ø±': 13, 'Ø«Ù„Ø§Ø« Ø¹Ø´Ø±': 13, 'Ø£Ø±Ø¨Ø¹Ø© Ø¹Ø´Ø±': 14, 'Ø£Ø±Ø¨Ø¹ Ø¹Ø´Ø±': 14,
        'Ø®Ù…Ø³Ø© Ø¹Ø´Ø±': 15, 'Ø®Ù…Ø³ Ø¹Ø´Ø±': 15, 'Ø³ØªØ© Ø¹Ø´Ø±': 16, 'Ø³Øª Ø¹Ø´Ø±': 16,
        'Ø³Ø¨Ø¹Ø© Ø¹Ø´Ø±': 17, 'Ø³Ø¨Ø¹ Ø¹Ø´Ø±': 17, 'Ø«Ù…Ø§Ù†ÙŠØ© Ø¹Ø´Ø±': 18, 'Ø«Ù…Ø§Ù†ÙŠ Ø¹Ø´Ø±': 18, 'Ø«Ù…Ø§Ù† Ø¹Ø´Ø±': 18,
        'ØªØ³Ø¹Ø© Ø¹Ø´Ø±': 19, 'ØªØ³Ø¹ Ø¹Ø´Ø±': 19, 'Ø¹Ø´Ø±ÙˆÙ†': 20, 'Ø¹Ø´Ø±ÙŠÙ†': 20,
        'Ø«Ù„Ø§Ø«ÙˆÙ†': 30, 'Ø«Ù„Ø§Ø«ÙŠÙ†': 30, 'Ø£Ø±Ø¨Ø¹ÙˆÙ†': 40, 'Ø£Ø±Ø¨Ø¹ÙŠÙ†': 40,
        'Ø®Ù…Ø³ÙˆÙ†': 50, 'Ø®Ù…Ø³ÙŠÙ†': 50, 'Ø³ØªÙˆÙ†': 60, 'Ø³ØªÙŠÙ†': 60,
        'Ø³Ø¨Ø¹ÙˆÙ†': 70, 'Ø³Ø¨Ø¹ÙŠÙ†': 70, 'Ø«Ù…Ø§Ù†ÙˆÙ†': 80, 'Ø«Ù…Ø§Ù†ÙŠÙ†': 80,
        'ØªØ³Ø¹ÙˆÙ†': 90, 'ØªØ³Ø¹ÙŠÙ†': 90, 'Ù…Ø¦Ø©': 100, 'Ù…Ø§Ø¦Ø©': 100, 'Ù…ÙŠØ©': 100
    }

    if txt in nums:
        return nums[txt]

    try:
        return int(txt)
    except ValueError:
        return None

def has_permission(uid, level):
    if storage.is_main_owner(uid):
        return True
    if level == "admin":
        return storage.is_admin(uid) or storage.is_owner(uid)
    if level == "owner":
        return storage.is_owner(uid)
    return False

managers = {
    "Ø¬Ù…Ù…": RemoteManager(URLS["Ø¬Ù…Ù…"]),
    "ÙˆÙŠÙƒÙŠ": RemoteManager(URLS["ÙˆÙŠÙƒÙŠ"]),
    "Ø´Ø±Ø·": RemoteManager(URLS["Ø´Ø±Ø·"]),
    "ÙÙƒÙƒ": RemoteManager(URLS["ÙÙƒÙƒ"], disasm=True),
    "ØµØ¬": RemoteManager(URLS["ØµØ¬"]),
    "Ø´Ùƒ": RemoteManager(URLS["Ø´Ùƒ"]),
    "Ø¬Ø´": CSVQuotesManager(URLS["Ø¬Ø´"]),
    "Ø¯Ø¨Ù„": RemoteManager(URLS["Ø¯Ø¨Ù„"]),
    "ØªØ±": RemoteManager(URLS["ØªØ±"]),
    "Ø¹ÙƒØ³": RemoteManager(URLS["Ø¹ÙƒØ³"]),
    "ÙØ±": RemoteManager(URLS["ÙØ±"]),
    "E": RemoteManager(URLS["E"], is_english=True)
}

async def cmd_start(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    msg = (
        " Ø§Ø±Ø±Ø±Ø­Ø¨ ÙÙŠ Ø¨ÙˆØª Ğ¸Ä¸â„“ Ù„Ù„Ø·Ø¨Ø§Ø¹Ø© \n\n"
        "Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø§Ù„Ù…ØªØ§Ø­Ø©:\n"
        "- (Ø¬Ù…Ù…) - Ø¬Ù…Ù„ Ø¹Ø±Ø¨ÙŠØ©\n"
        "- (ÙˆÙŠÙƒÙŠ) - Ø¬Ù…Ù„ ÙˆÙŠÙƒÙŠØ¨ÙŠØ¯ÙŠØ§\n"
        "- (ØµØ¬) - Ù…ÙˆÙ„Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\n"
        "- (Ø´Ùƒ) - Ø¬Ù…Ù„ Ø¹Ø§Ù…ÙŠØ©\n"
        "- (Ø¬Ø´) - Ø§Ù‚ØªØ¨Ø§Ø³Ø§Øª\n"
        "- (ÙØ±) - Ø¬Ù…Ù„ ÙØ§Ø±Ø³ÙŠØ©\n"
        "- (E) - Ø¬Ù…Ù„ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n"
        "- (ÙƒØ±Ø±) - ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒÙ„Ù…Ø§Øª\n"
        "- (Ø´Ø±Ø·) - Ø¬Ù…Ù„ Ø¨Ø§Ù„Ø´Ø±ÙˆØ·\n"
        "- (ÙÙƒÙƒ) - ÙÙƒ ÙˆØªØ±ÙƒÙŠØ¨\n"
        "- (Ø¯Ø¨Ù„) - ØªÙƒØ±Ø§Ø± ÙƒÙ„ ÙƒÙ„Ù…Ø© Ù…Ø±ØªÙŠÙ†\n"
        "- (ØªØ±) - ØªÙƒØ±Ø§Ø± ÙƒÙ„ ÙƒÙ„Ù…Ø© Ø«Ù„Ø§Ø« Ù…Ø±Ø§Øª\n"
        "- (Ø¹ÙƒØ³) - ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¬Ù…Ù„Ø© Ø¨Ø§Ù„Ø¹ÙƒØ³\n\n"
        " Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª : \n\n"
        "-(Ø§Ù„ØµØ¯Ø§Ø±Ø©) - Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† \n" 
        "- (Ø¬ÙˆØ§Ø¦Ø²ÙŠ) - Ø¹Ø±Ø¶ Ø¬ÙˆØ§Ø¦Ø²Ùƒ\n"
        "- (ÙØªØ­ Ø¬ÙˆÙ„Ø©) - ÙØªØ­ Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©\n"
        "- (Ø¬ÙˆÙ„Ø©) - Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬ÙˆÙ„Ø©\n\n"
    )
    await u.message.reply_text(msg)

async def cmd_leaderboard(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    types = ["Ø¬Ù…Ù…", "ÙˆÙŠÙƒÙŠ", "ØµØ¬", "Ø´Ùƒ", "Ø¬Ø´", "ÙØ±", "E", "ÙƒØ±Ø±", "Ø´Ø±Ø·", "ÙÙƒÙƒ", "Ø¯Ø¨Ù„", "ØªØ±", "Ø¹ÙƒØ³"]
    sections = []

    for typ in types:
        lb = storage.get_leaderboard(typ)
        if lb:
            s = f"{typ}\n"
            for i, (uid_str, username, first_name, wpm) in enumerate(lb, 1):
                display = f"@{username}" if username else first_name
                s += f"{i}. {display}: {wpm:.2f} WPM\n"
            sections.append(s)

    if sections:
        await u.message.reply_text("\n".join(sections))
    else:
        await u.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯")

async def cmd_awards(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    awards = storage.get_awards(uid)
    if not awards:
        await u.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆØ§Ø¦Ø² Ù„Ø¯ÙŠÙƒ Ø¨Ø¹Ø¯")
        return

    msg = "Ø¬ÙˆØ§Ø¦Ø²Ùƒ:\n\n"
    for aw in awards:
        dt = datetime.fromisoformat(aw['date']).strftime('%Y-%m-%d')
        msg += f"â€¢ {aw['name']} - {aw['type']}: {aw['wpm']:.2f} WPM ({dt})\n"

    await u.message.reply_text(msg)

async def cmd_round(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id
    cid = u.effective_chat.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    existing_round = storage.get_round(cid)
    if existing_round:
        await u.message.reply_text("ÙÙŠÙ‡ Ø¬ÙˆÙ„Ø© Ø´ØºØ§Ù„Ø© ÙŠØ§ Ù‚ÙÙ„Ù‡Ø§ Ø¨ Ø§Ù†Ù‡Ø§Ø¡ Ø¬ÙˆÙ„Ø© Ø§Ùˆ Ø§Ø®ØªØ§Ø± Ø±Ù‚Ù… Ù„ÙØ¸Ø§ Ø§Ùˆ Ø±Ù‚Ù…Ø§")
        return

    storage.set_pending_round_setup(cid, uid, True)
    await u.message.reply_text("ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ù†ØªØµØ§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„ÙÙˆØ² ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø©ØŸ\nØ£Ø¯Ø®Ù„ Ø§Ù„Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 100 (Ù…Ø«Ø§Ù„: 5 Ø£Ùˆ Ø®Ù…Ø³Ø©)")
    
    await asyncio.sleep(20)
    
    if storage.get_pending_round_setup(cid) == uid:
        storage.set_pending_round_setup(cid, uid, False)
        await c.bot.send_message(chat_id=cid, text="Ù„Ù… ÙŠØ®ØªØ± Ù…Ù†Ø´Ø¦ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§ÙŠ Ø¹Ø¯Ø¯ Ù„Ø°Ø§ Ø§ÙØªØ­ÙˆØ§ Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©")

async def cmd_show_round(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id
    cid = u.effective_chat.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    existing_round = storage.get_round(cid)
    if not existing_round:
        await u.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆÙ„Ø© Ù…ÙØªÙˆØ­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹")
        return

    stats = storage.get_round_stats(cid)
    await u.message.reply_text(stats)

async def cmd_end_round(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id
    cid = u.effective_chat.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    round_data = storage.get_round(cid)
    if not round_data:
        await u.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆÙ„Ø© Ù…ÙØªÙˆØ­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹")
        return

    starter_uid = round_data.get("starter_uid")
    is_starter = (starter_uid == uid)
    
    is_admin = False
    try:
        chat_member = await c.bot.get_chat_member(cid, uid)
        is_admin = chat_member.status in ['creator', 'administrator']
    except:
        pass

    if not is_starter and not is_admin:
        await u.message.reply_text("Ù…Ù†Ø´Ø¦ Ø§Ù„Ø¬ÙˆÙ„Ø© ÙŠÙ†Ù‡ÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© ÙÙ‚Ø· Ø§Ùˆ Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
        return

    storage.end_round(cid)
    await u.message.reply_text("ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬ÙˆÙ„Ø©")

async def cmd_ban(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    if not has_permission(uid, "admin"):
        await u.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return

    if u.message.reply_to_message:
        target_uid = u.message.reply_to_message.from_user.id

        if storage.is_main_owner(target_uid):
            await u.message.reply_text("Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø§Ù„Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ")
            return

        storage.ban_user(target_uid)
        await u.message.reply_text(f"ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    else:
        await u.message.reply_text("Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø­Ø¸Ø±Ù‡")

async def cmd_unban(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    if not has_permission(uid, "admin"):
        await u.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·")
        return

    if u.message.reply_to_message:
        target_uid = u.message.reply_to_message.from_user.id
        success = storage.unban_user(target_uid)
        if success:
            await u.message.reply_text(f"ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
        else:
            await u.message.reply_text(f"Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±")
    else:
        await u.message.reply_text("Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡")

async def cmd_broadcast_start(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    if not has_permission(uid, "owner"):
        await u.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø§Ù„ÙƒÙŠÙ† ÙÙ‚Ø·")
        return

    storage.set_broadcast_mode(uid, True)
    await u.message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©. Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø°Ø§Ø¹ØªÙ‡Ø§ Ø§Ù„Ø¢Ù†.")

async def cmd_stats(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    if not storage.is_main_owner(uid):
        await u.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø§Ù„Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ÙÙ‚Ø·")
        return

    total_users = len(storage.data["users"])
    total_chats = len(storage.data["chats"])
    banned = len(storage.data["banned"])

    stats_details = "\n\nØ¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ù‚Ø³Ø§Ù…:\n"
    types = ["Ø¬Ù…Ù…", "ÙˆÙŠÙƒÙŠ", "ØµØ¬", "Ø´Ùƒ", "Ø¬Ø´", "ÙØ±", "E", "ÙƒØ±Ø±", "Ø´Ø±Ø·", "ÙÙƒÙƒ", "Ø¯Ø¨Ù„", "ØªØ±", "Ø¹ÙƒØ³"]

    total_usage = {}
    for date, commands in storage.data["stats"].items():
        for cmd, count in commands.items():
            if cmd in types:
                total_usage[cmd] = total_usage.get(cmd, 0) + count

    for typ in types:
        usage = total_usage.get(typ, 0)
        stats_details += f"â€¢ {typ}: {usage} Ù…Ø±Ø©\n"

    msg = (
        f"ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª:\n\n"
        f"Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}\n"
        f"Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {total_chats}\n"
        f"Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: {banned}"
        f"{stats_details}"
    )

    await u.message.reply_text(msg)

async def cmd_supervision(u: Update, c: ContextTypes.DEFAULT_TYPE):
    uid = u.effective_user.id

    if storage.is_banned(uid):
        await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    msg = "ğŸ‘¥ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø´Ø±Ø§Ù:\n\n"

    msg += "ğŸ”° Ø§Ù„Ù…Ø§Ù„Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:\n"
    owner_data = storage.data["users"].get(str(OWNER_ID), {})
    owner_username = owner_data.get("username")
    if owner_username:
        msg += f"â€¢ @{owner_username}\n"
    else:
        msg += f"â€¢ {owner_data.get('first_name', 'Ø§Ù„Ù…Ø§Ù„Ùƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ')}\n"

    owners = storage.get_all_owners()
    if owners:
        msg += "\nğŸ‘‘ Ø§Ù„Ù…Ù„Ø§Ùƒ:\n"
        for owner_id in owners:
            user_data = storage.data["users"].get(str(owner_id), {})
            username = user_data.get("username")
            if username:
                msg += f"â€¢ @{username}\n"
            else:
                msg += f"â€¢ {user_data.get('first_name', 'Ù…Ø§Ù„Ùƒ')}\n"

    admins = storage.get_all_admins()
    if admins:
        msg += "\nâ­ Ø§Ù„Ø§Ø¯Ù…Ù†Ø²:\n"
        for admin_id in admins:
            user_data = storage.data["users"].get(str(admin_id), {})
            username = user_data.get("username")
            if username:
                msg += f"â€¢ @{username}\n"
            else:
                msg += f"â€¢ {user_data.get('first_name', 'Ø§Ø¯Ù…Ù†')}\n"

    if not owners and not admins:
        msg += "\nÙ„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ø§Ùƒ Ø£Ùˆ Ø§Ø¯Ù…Ù†Ø² Ø­Ø§Ù„ÙŠØ§Ù‹."

    await u.message.reply_text(msg)

async def handle_msg(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not u.message or not u.message.text:
        return

    uid = u.effective_user.id
    cid = u.effective_chat.id
    text = u.message.text.strip()
    usr = u.effective_user.username
    name = u.effective_user.first_name

    storage.add_user(uid, usr, name)

    if u.effective_chat.type in ['group', 'supergroup']:
        chat_title = u.effective_chat.title
        storage.add_chat(cid, chat_title)

    if u.message.reply_to_message and storage.is_main_owner(uid):
        replied_user = u.message.reply_to_message.from_user
        replied_uid = replied_user.id
        replied_username = replied_user.username
        replied_name = replied_user.first_name

        auto_reply_commands = ["Ø¨Ø§Ù†Ø¯", "ØªÙ‚ÙŠÙŠØ¯", "ÙƒØªÙ…", "Ø§Ù„ØºØ§Ø¡ ØªÙ‚ÙŠÙŠØ¯", "Ø§Ù„ØºØ§Ø¡ Ø¨Ø§Ù†Ø¯", "Ø·Ø±Ø¯", "Ø§Ù„ØºØ§Ø¡ ÙƒØªÙ…"]

        if text in auto_reply_commands:
            await u.message.reply_to_message.reply_text(text)
            return

        if text == "Ø±ÙØ¹ Ø§Ø¯Ù…Ù†":
            storage.add_admin(replied_uid)
            mention = f"@{replied_username}" if replied_username else replied_name
            await u.message.reply_text(f"ØªÙ… Ø±ÙØ¹ {mention} Ø¥Ù„Ù‰ Ø±ØªØ¨Ø© Ø§Ø¯Ù…Ù†")
            return

        if text == "Ø±ÙØ¹ Ù…Ø§Ù„Ùƒ":
            storage.add_owner(replied_uid)
            mention = f"@{replied_username}" if replied_username else replied_name
            await u.message.reply_text(f"ØªÙ… Ø±ÙØ¹ {mention} Ø¥Ù„Ù‰ Ø±ØªØ¨Ø© Ù…Ø§Ù„Ùƒ")
            return

    if storage.is_banned(uid):
        commands = ["Ø§Ù„ØµØ¯Ø§Ø±Ø©", "Ø¬ÙˆØ§Ø¦Ø²ÙŠ", "Ø¬ÙˆÙ„Ø©", "ÙØªØ­ Ø¬ÙˆÙ„Ø©", "Ø¨Ø§Ù†Ø¯", "Ø§Ù„ØºØ§Ø¡ Ø¨Ø§Ù†Ø¯", "Ø¥Ø°Ø§Ø¹Ø©", "Ø§Ø­ØµØ§Ø¡", "Ø§Ù„Ø¥Ø´Ø±Ø§Ù",
                   "Ø¬Ù…Ù…", "ÙˆÙŠÙƒÙŠ", "ØµØ¬", "Ø´Ùƒ", "Ø¬Ø´", "ÙØ±", "E", "ÙƒØ±Ø±", "Ø´Ø±Ø·", "ÙÙƒÙƒ", "Ø¯Ø¨Ù„", "ØªØ±", "Ø¹ÙƒØ³", "Ø¹Ø±Ø¶", "Ù…Ù‚Ø§Ù„Ø§Øª"]
        is_command = any(text.startswith(cmd) for cmd in commands)

        if is_command:
            await u.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± ØªÙˆØ§ØµÙ„ Ù…Ø¹ @XXVV_99")
        return

    if storage.get_broadcast_mode(uid):
        storage.set_broadcast_mode(uid, False)
        sent = 0
        failed = 0
        for chat_id in storage.data["chats"].keys():
            try:
                await c.bot.send_message(chat_id=int(chat_id), text=text)
                sent += 1
            except Exception as e:
                failed += 1
                print(f"Failed to send to {chat_id}: {e}")

        await u.message.reply_text(f"ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ {sent} Ù…Ø¬Ù…ÙˆØ¹Ø©. ÙØ´Ù„: {failed}")
        return

    pending_setup = storage.get_pending_round_setup(cid)
    if pending_setup == uid:
        target = arabic_to_num(text)
        if target is None:
            try:
                target = int(text)
            except ValueError:
                await u.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ù…Ù† 1 Ø¥Ù„Ù‰ 100")
                return

        if target < 1 or target > 100:
            await u.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 100")
            return

        storage.set_pending_round_setup(cid, uid, False)
        storage.start_round(cid, target, uid)
        storage.set_round_mode(cid, True)
        await u.message.reply_text(f"ØªÙ… ÙØªØ­ Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† {target} Ø§Ù†ØªØµØ§Ø±!")
        return

    current_time = time.time()
    if current_time - last_command_time[cid][text] < 1:
        return
    last_command_time[cid][text] = current_time

    if text == "Ø§Ù„ØµØ¯Ø§Ø±Ø©":
        await cmd_leaderboard(u, c)
        storage.log_cmd("Ø§Ù„ØµØ¯Ø§Ø±Ø©")
        return

    if text == "Ø¬ÙˆØ§Ø¦Ø²ÙŠ":
        await cmd_awards(u, c)
        storage.log_cmd("Ø¬ÙˆØ§Ø¦Ø²ÙŠ")
        return

    if text == "Ø¬ÙˆÙ„Ø©":
        await cmd_show_round(u, c)
        storage.log_cmd("Ø¬ÙˆÙ„Ø©")
        return

    if text.startswith("ÙØªØ­ Ø¬ÙˆÙ„Ø©"):
        await cmd_round(u, c)
        storage.log_cmd("ÙØªØ­ Ø¬ÙˆÙ„Ø©")
        return

    if text == "Ø§Ù†Ù‡Ø§Ø¡ Ø¬ÙˆÙ„Ø©":
        await cmd_end_round(u, c)
        storage.log_cmd("Ø§Ù†Ù‡Ø§Ø¡ Ø¬ÙˆÙ„Ø©")
        return

    if text == "Ø¨Ø§Ù†Ø¯":
        await cmd_ban(u, c)
        storage.log_cmd("Ø¨Ø§Ù†Ø¯")
        return

    if text == "Ø§Ù„ØºØ§Ø¡ Ø¨Ø§Ù†Ø¯":
        await cmd_unban(u, c)
        storage.log_cmd("Ø§Ù„ØºØ§Ø¡ Ø¨Ø§Ù†Ø¯")
        return

    if text == "Ø¥Ø°Ø§Ø¹Ø©":
        await cmd_broadcast_start(u, c)
        storage.log_cmd("Ø¥Ø°Ø§Ø¹Ø©")
        return

    if text == "Ø§Ø­ØµØ§Ø¡":
        await cmd_stats(u, c)
        storage.log_cmd("Ø§Ø­ØµØ§Ø¡")
        return

    if text == "Ø§Ù„Ø¥Ø´Ø±Ø§Ù":
        await cmd_supervision(u, c)
        storage.log_cmd("Ø§Ù„Ø¥Ø´Ø±Ø§Ù")
        return

    if text in ["Ø¹Ø±Ø¶", "Ù…Ù‚Ø§Ù„Ø§Øª"]:
        await cmd_start(u, c)
        storage.log_cmd(text)
        return

    active_sessions = storage.get_all_active_sessions(cid)

    if text in ["Ø¬Ù…Ù…", "ÙˆÙŠÙƒÙŠ", "ØµØ¬", "Ø´Ùƒ", "Ø¬Ø´", "ÙØ±", "E"]:
        storage.log_cmd(text)
        sent = managers[text].get()
        storage.save_session(uid, cid, text, sent, time.time(), sent=True)
        display = format_display(sent)
        await u.message.reply_text(display)
        return

    if text == "ÙƒØ±Ø±":
        storage.log_cmd("ÙƒØ±Ø±")
        pattern = gen_pattern(uid)
        storage.save_session(uid, cid, "ÙƒØ±Ø±", pattern, time.time(), sent=True)
        await u.message.reply_text(pattern)
        return

    if text == "Ø´Ø±Ø·":
        storage.log_cmd("Ø´Ø±Ø·")
        sent = managers["Ø´Ø±Ø·"].get()
        cond = random.choice(CONDITIONS)
        full = f"{sent}||{cond}"
        storage.save_session(uid, cid, "Ø´Ø±Ø·", full, time.time(), sent=True)
        await u.message.reply_text(cond)
        await asyncio.sleep(2)
        await c.bot.send_message(chat_id=cid, text=format_display(sent))
        return

    if text == "ÙÙƒÙƒ":
        storage.log_cmd("ÙÙƒÙƒ")
        sent = managers["ÙÙƒÙƒ"].get()
        storage.save_session(uid, cid, "ÙÙƒÙƒ_ØªÙÙƒÙŠÙƒ", sent, time.time(), sent=True)
        await u.message.reply_text(format_display(sent))
        return

    if text == "Ø¯Ø¨Ù„":
        storage.log_cmd("Ø¯Ø¨Ù„")
        sent = managers["Ø¯Ø¨Ù„"].get()
        storage.save_session(uid, cid, "Ø¯Ø¨Ù„", sent, time.time(), sent=True)
        await u.message.reply_text(format_display(sent))
        return

    if text == "ØªØ±":
        storage.log_cmd("ØªØ±")
        sent = managers["ØªØ±"].get()
        storage.save_session(uid, cid, "ØªØ±", sent, time.time(), sent=True)
        await u.message.reply_text(format_display(sent))
        return

    if text == "Ø¹ÙƒØ³":
        storage.log_cmd("Ø¹ÙƒØ³")
        sent = managers["Ø¹ÙƒØ³"].get()
        storage.save_session(uid, cid, "Ø¹ÙƒØ³", sent, time.time(), sent=True)
        await u.message.reply_text(format_display(sent))
        return

    for session in active_sessions:
        typ = session.get("type")
        orig = session.get("text")
        start_time = session.get("time")
        elapsed = time.time() - start_time

        if elapsed > 60:
            continue

        matched = False

        if typ in ["Ø¬Ù…Ù…", "ÙˆÙŠÙƒÙŠ", "ØµØ¬", "Ø´Ùƒ", "Ø¬Ø´", "ÙØ±", "E"]:
            if match_text(orig, text):
                matched = True
        elif typ == "ÙƒØ±Ø±":
            valid, err = validate_repeat(orig, text)
            if valid:
                matched = True
        elif typ == "Ø´Ø±Ø·":
            orig_s, cond = orig.split('||')
            valid, exp = validate_condition(cond, orig_s, text)
            if valid:
                matched = True
        elif typ == "ÙÙƒÙƒ_ØªÙÙƒÙŠÙƒ":
            if is_correct_disassembly(orig, text):
                matched = True
        elif typ == "Ø¯Ø¨Ù„":
            valid, err = validate_double(orig, text)
            if valid:
                matched = True
        elif typ == "ØªØ±":
            valid, err = validate_triple(orig, text)
            if valid:
                matched = True
        elif typ == "Ø¹ÙƒØ³":
            valid, err = validate_reverse(orig, text)
            if valid:
                matched = True

        if matched:
            word_count = count_words_for_wpm(text)
            wpm = (word_count / elapsed) * 60
            score_typ = 'ÙÙƒÙƒ' if typ == 'ÙÙƒÙƒ_ØªÙÙƒÙŠÙƒ' else typ
            storage.update_score(uid, score_typ, wpm)

            round_data = storage.get_round(cid)
            if round_data:
                storage.update_round_activity(cid)
                wins = storage.add_win(cid, uid)
                target = round_data['target']
                wins_list = round_data.get('wins', {})
                mention = f"@{usr}" if usr else name

                round_stats = "\n\nØ¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬ÙˆÙ„Ø©:\n"
                sorted_wins = sorted(wins_list.items(), key=lambda x: x[1], reverse=True)
                for i, (user_id, user_wins) in enumerate(sorted_wins, 1):
                    if i <= 3:
                        user_data = storage.data["users"].get(str(user_id), {})
                        user_name = user_data.get("first_name", "Ù…Ø³ØªØ®Ø¯Ù…")
                        user_username = user_data.get("username")
                        user_mention = f"@{user_username}" if user_username else user_name
                        round_stats += f"{i}. {user_mention}: {user_wins}/{target}\n"

                if wins >= target:
                    await u.message.reply_text(
                        f"Ù…Ø¨Ø±ÙˆÙƒ {mention}!\n"
                        f"Ø£Ù†Øª Ø§Ù„ÙØ§Ø¦Ø² ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø©!\n"
                        f"Ø§Ù„Ø³Ø±Ø¹Ø©: {wpm:.2f} WPM\n"
                        f"Ø§Ù„ÙÙˆØ² Ø±Ù‚Ù…: {wins}/{target}"
                        f"{round_stats}"
                    )
                    storage.end_round(cid)
                else:
                    await u.message.reply_text(
                        f"ØµØ­ÙŠØ­ {mention}!\n"
                        f"Ø§Ù„Ø³Ø±Ø¹Ø©: {wpm:.2f} WPM\n"
                        f"Ø§Ù„ØªÙ‚Ø¯Ù…: {wins}/{target}"
                        f"{round_stats}"
                    )
            else:
                await u.message.reply_text(f"Ù…Ù…ØªØ§Ø² Ø³Ø±Ø¹ØªÙƒ! {wpm:.2f} WPM")

            storage.del_session(cid, typ)
            break

    storage.save()

async def periodic_save():
    while True:
        await asyncio.sleep(save_interval)
        storage.save()

async def periodic_cleanup():
    while True:
        await asyncio.sleep(3600)
        storage.cleanup()
        storage.save(force=True)

async def periodic_round_cleanup():
    while True:
        await asyncio.sleep(30)
        removed = storage.cleanup_inactive_rounds()
        if removed:
            print(f"Removed {len(removed)} inactive rounds")
            storage.save(force=True)

async def handle_callback(u: Update, c: ContextTypes.DEFAULT_TYPE):
    query = u.callback_query
    await query.answer()

    if query.data.startswith("end_round_"):
        cid = int(query.data.split("_")[2])

        round_data = storage.get_round(cid)
        if round_data:
            wins_list = round_data.get('wins', {})
            if wins_list:
                msg = "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¬ÙˆÙ„Ø©:\n\n"
                sorted_wins = sorted(wins_list.items(), key=lambda x: x[1], reverse=True)
                for i, (user_id, wins) in enumerate(sorted_wins, 1):
                    user_data = storage.data["users"].get(str(user_id), {})
                    user_name = user_data.get("first_name", "Ù…Ø³ØªØ®Ø¯Ù…")
                    user_username = user_data.get("username")
                    mention = f"@{user_username}" if user_username else user_name
                    msg += f"{i}. {mention}: {wins} ÙÙˆØ²\n"
                await query.edit_message_text(msg)

            storage.end_round(cid)
            await query.message.reply_text("ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬ÙˆÙ„Ø©")
        else:
            await query.edit_message_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬ÙˆÙ„Ø© Ù†Ø´Ø·Ø© Ø­Ø§Ù„ÙŠØ§Ù‹")

async def post_init(application: Application):
    asyncio.create_task(periodic_save())
    asyncio.create_task(periodic_cleanup())
    asyncio.create_task(periodic_round_cleanup())
    print("[BACKGROUND] Started background tasks: periodic_save, periodic_cleanup, periodic_round_cleanup")

def main():
    if not BOT_TOKEN:
        print("Error: BOT_TOKEN environment variable not set!")
        return

    app = Application.builder().token(BOT_TOKEN).concurrent_updates(True).post_init(post_init).build()

    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_msg))

    print("Bot starting...")
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
